# AUTOGENERATED! DO NOT EDIT! File to edit: 09_base.ipynb (unless otherwise specified).

__all__ = ['ItemDict', 'Properties', 'BaseElement', 'BaseConstitutive', 'BaseLinearSolver']

# Cell
import pandas as pd
import numpy as np
import scipy
import torch
from scipy.io import loadmat
from .utils import *
from .shape import getElemetType
from .io import jsonReader

# Cell
class ItemDict(dict):

    def add(self, Id, item):
        self[Id] = item

    def get(self, Ids):
        return (self[Ids] if isinstance(Ids,int) else [self[Id] for Id in Ids]
                if isinstance(Ids,list) else "NAN")

    def getData(self, Ids):
        return {Id:self[Id] for Id in Ids}

# Cell
class Properties:

    def __init__ (self, props={}):

        for key in props.keys():
            setattr(self, key, props[key])

    def __str__ (self):
        att_prop  = ''

        for att in dir(self):
            if att.startswith('__') or att.startswith('store'):
                continue

            att_prop += 'Attribute: ' + att + '\n'
            att_prop += str(getattr(self,att)) + '\n'

        return att_prop

    def __iter__ ( self ):
        propsList = []

        for att in dir(self):
            if att.startswith('__') or att.startswith('store'):
                continue
            propsList.append((att, getattr(self,att)))

        return iter(propsList)

    def store (self, key, val):
        setattr(self, key, val)

# Cell
class BaseElement(dict):

    def __init__ (self, numElem, nodes, elems, group, shape, mat, consti):

        self.numElem     = numElem
        self.nodes       = elems[numElem][0]
        self.nodesCoords = nodes
        self.elemType    = getElemetType(np.array([coord for node, coord in self.nodesCoords.items()]))
        self.Le          = elems[numElem][1]
        self.gp          = shape["gp"]
        self.we          = shape["we"]
        self.N           = shape["N"]
        self.dN          = shape["dN"]
        self.group       = group
        self.mat         = mat
        self.consti      = consti

        self.iIter = -1
        self.history_nodes = pd.DataFrame({"iter":[0]})
        self.history_gps   = pd.DataFrame({"iter":[0]})
        self.current = {"iter":0}

        self.add(self.numElem, self.elemType)

    def add(self, Id, item):
        self[Id] = item

    def setIter(self, iIter):
        self.iIter = iIter

    def setHistoryNodesParameter(self, name, val):
        if self.iIter == -1:
            self.history_nodes[name]=val

    def setHistoryGaussParameter(self, name, val):
        if self.iIter == -1:
            self.history_gps[name]=val

    def setCurrentParameter(self, name, val):
        if self.iIter == -1:
            self.current[name]=val

    def getHistoryNodesParameter(self, iIter, name):
        return self.history_nodes.loc[iIter,name]

    def getHistoryGaussParameter(self, iIter, name):
        return self.history_gps.loc[iIter,name]

    def getCurrentParameter(self, name):
        return self.current[name]

    def commitHistory(self):
        self.setIter(0)
        self.history_nodes = self.history_nodes.append(self.current, ignore_index=True)
        self.history_gps   = self.history_gps.append(self.current, ignore_index=True)
        for key, val in self.current.items():
            self.current[key] = 0.

# Cell
class BaseConstitutive:

    def __init__(self, props):
        for name,val in props.items():
            dim = eval(val["dim"])
            value = val["value"]
            setattr(self, name, value*dim)

        self.history = pd.DataFrame({"i":[0], "d_epsilon":[0]})
        self.current = {"i":0, "d_epsilon":0}
        self.iIter   = -1

    def setIter(self, iIter):
        self.iIter = iIter

    def setHistoryParameter(self, name, val):
        if self.iIter == -1:
            self.history[name]=val
            self.current[name]=val

    def getHistoryParameter(self, name, k):
        return self.history.loc[k,name]

    def setCurrentParameter(self, name, val):
        self.current[name]=val

    def getCurrentParameter(self, name):
        return self.current[name]

    def commitHistory(self):
        self.setIter(0)
        self.history = self.history.append(self.current, ignore_index=True)
        for key, val in self.current.items():
            self.current[key] = 0.


# Cell
class BaseLinearSolver:
    def __init__(self, A, b, xo=np.array([]), tol=1e-10, maxIter=10000):
        self.device  = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.A       = A
        self.b       = b
        self.xo      = xo
        self.tol     = tol
        self.maxIter = maxIter


        if not self.xo.any():
            self.xo = 10*np.random.randn(self.A.todense().shape[0],1)

        if not scipy.sparse.issparse(self.A):
            self.A_sparsity = 1.0-np.count_nonzero(self.A)/self.A.size
            if self.A_sparsity >= 2./3:
                self.A = scipy.sparse.csr_matrix(self.A)
        elif scipy.sparse.isspmatrix_coo(self.A) or scipy.sparse.isspmatrix_csc(self.A):
            self.A = self.A.tocsr()

        if not scipy.sparse.issparse(self.b):
            self.b_sparsity = 1.0-np.count_nonzero(self.b)/self.b.size
            if self.b_sparsity >= 2./3:
                self.b = scipy.sparse.csr_matrix(self.b)
        elif scipy.sparse.isspmatrix_coo(self.b) or scipy.sparse.isspmatrix_csc(self.b):
            self.b = self.b.tocsr()

        if self.device == torch.device(type='cuda'):
            self.xo = torch.from_numpy(self.xo).type(torch.float64).to(self.device)
            self.b  = torch.from_numpy(self.b).type(torch.float64).to(self.device)
            self.A  = torch.from_numpy(self.A.todense()).type(torch.float64).to(self.device)
